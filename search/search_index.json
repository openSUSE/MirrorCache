{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-mirrorcache","title":"Welcome to MirrorCache!","text":"<p>MirrorCache is a Web Server for files download, which will route download requests to an appropriate mirror. MirrorCache doesn't store files and instead keeps in DB list of files from the <code>Main Server</code>.</p> <p>According to Wikipedia \"Cache - is a component that stores data so that future requests for that data can be served faster\". In this regard MirrorCache is a cache of (meta)information about geographical location of files.</p> <p>\"Cache hit\" means that MirrorCache was able to redirect to proper (the closest) mirror. \"Cache miss\" means that MirrorCache had to redirect request to the <code>Main Server</code>.</p> <p>Output below domonstrates a cache miss, so the download request will be redirected to the <code>Main Server</code> (in this case download.opensuse.org):</p> <pre><code>&gt; curl -I http://mirrorcache.opensuse.org/download/update/openSUSE-current/x86_64/alsa-1.1.5-lp152.8.6_lp152.9.4.1.x86_64.drpm\nHTTP/1.1 302 Found\nlocation: http://download.opensuse.org/update/openSUSE-current/x86_64/alsa-1.1.5-lp152.8.6_lp152.9.4.1.x86_64.drpm\ndate: Wed, 29 Jul 2020 08:37:07 GMT\n</code></pre> <p>Then background jobs will collect info about the hottest misses and scan predefined mirrors for presence of these files. Further requests will be redirected to one of the mirrors that has the file:</p> <pre><code>&gt; curl -I http://mirrorcache.opensuse.org/download/update/openSUSE-current/x86_64/alsa-1.1.5-lp152.8.6_lp152.9.4.1.x86_64.drpm\nHTTP/1.1 302 Found\nlocation: http://ftp.gwdg.de/pub/opensuse/update/openSUSE-current/x86_64/alsa-1.1.5-lp152.8.6_lp152.9.4.1.x86_64.drpm\ndate: Wed, 29 Jul 2020 08:40:00 GMT\n</code></pre> <p>The project was implemented as a quick hack with some amount of shortcuts to make things going. The goal is to improve it over time with the main focus to do the job.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>The motivation behind this project is to rethink architecture of mirrorbrain https://github.com/poeml/mirrorbrain with following features: - job queue; - web UI; - fileless approach means that application doesn't require physical access to managed files; - properly handle http/https and ipv4/ipv6 requests by picking a mirror which is able to serve that; - geo-cluster feature allows to configure an instance per region, where each instance scan only mirrors from own region.</p>"},{"location":"#how-to-report-issues-or-ask-questions","title":"How to report issues or ask questions:","text":"<p>Write an email to andrii.nikitin on domain suse.com or use the issue tracker at https://github.com/openSUSE/MirrorCache/</p>"},{"location":"flow/","title":"Overview and concept","text":"<p>Here is the perfect place to provide a nice picture of the process...</p>"},{"location":"mb_compare/","title":"MirrorCache (mc) concept vs MirrorBrain (mb) concept","text":""},{"location":"mb_compare/#scanning","title":"Scanning","text":"<ol> <li>mb uses daily full scan of all files on all mirrors, without regard of whether files were ever downloaded or changed recently. This may be waste of resources. mc scans only those locations which are needed by users and prioritize the scans according to popularity.</li> <li>It may take up to 24 hours before mb notices that file has gone from a mirror. Clients will be incorrectly redirected and receive 404 error. mc is making sure that file exists on selected mirror and never redirects to locations where file was missing for a while.</li> <li>New files are added by scanners in mb, which needs careful handling of deadlocks when two scanners attempt to add the same files. mc has separate jobs for keeping in sync information about files on the Main Server and for scanning mirrors. In addition, jobs have natural locking mechanism (https://docs.mojolicious.org/Minion#lock), which prevents conflicting operations.</li> <li>New files are added by scanners in mb, which currently leads to many incorrect files in database. (Potentially overload of mb DB because of incorrectly configured mirror). (This may be fixed in cost of added coupling on mb architecture).</li> </ol>"},{"location":"mb_compare/#jobs-queue","title":"Jobs queue","text":"<ul> <li>mb relies on command line tool and cron to run jobs. User then manually reviews logs to find eventual problems (which is a challenge to do with current amount of logging).</li> <li>mc has a popular, mature, fast and asynchronous job queue: https://docs.mojolicious.org/Minion, which includes prioritization, rescheduling, custom job queues, scalability (adding workers), manageability (assigning workers to particular queues), dashboard, search, etc.</li> </ul>"},{"location":"mb_compare/#www","title":"WWW","text":"<ul> <li>mb relies on rendering of static files generated by a cron job.</li> <li>mc uses the mojolicious.org framework, which has delayed rendering, javascript, etc.</li> </ul>"},{"location":"mb_compare/#fileless-architecture","title":"Fileless architecture","text":"<ol> <li> <p>Architecture</p> <ul> <li>By design mb uses local files for rendering directories in WebUI and for scanner jobs to detect files present on mirror. It is a complication for using several geographical instances of mb, so it's possible to configure Apache plugins with some periodical sync jobs to store empty files instead of keeping full content of files.</li> <li>mc is fileless by design, so it should be easy to spawn a new mc instance, which will become useful immediately.</li> </ul> </li> <li> <p>Since at the moment filename is not enough to identify the content of a file (see https://github.com/openSUSE/open-build-service/issues/6690), additional identification is required (e.g. filesize + mtime). This will complicate mb approach even more. (It will need to sync additional info besides empty files).</p> </li> </ol>"},{"location":"mb_compare/#robustness","title":"Robustness","text":"<p>While mc may lead to eventual increased traffic to the main server, both mc and mb must rely on robustness of the main server.</p>"},{"location":"setup/","title":"Setup","text":""},{"location":"setup/#common-setup","title":"Common Setup","text":""},{"location":"setup/#environment-variables","title":"Environment variables","text":"<p>MirrorCache can be configured with following environment variables:</p> <ul> <li>MIRRORCACHE_ROOT (required): defines location of files, which needs redirection. It may be url, local folder or rsync address, e.g. <code>MIRRORCACHE_ROOT=http://download.opensuse.org</code> or <code>MIRRORCACHE_ROOT=/srv/mirrorcache</code> or <code>MIRRORCACHE_ROOT=rsync://user:password@myhost.com/module</code>. (Note that you must install additionally <code>perl-Digest-MD4</code> if rsync url needs password verification).</li> <li>MIRRORCACHE_AUTH_URL (optional) may contain remote openid server url (default https://www.opensuse.org/openid/user/). if explicitly set to empty value - all login attempt will be allowed and user set to 'Demo'.</li> <li>MIRRORCACHE_TOP_FOLDERS (space separated values) may be set to automatically redirect /folder to /download/folder.</li> <li>For reference of using MOJO_LISTEN variable refer Mojolicious documentation, e.g. <code>MOJO_LISTEN=http://*:8000</code></li> <li>It is recommended to run MirrorCache daemon behind another streamline WebService, e.g. Apache or haproxy. Thus <code>MOJO_REVERSE_PROXY=1</code> will be needed.</li> <li>MIRRORCACHE_REDIRECT is needed for use when MIRRORCACHE_ROOT is set to remote address. Requests will be redirected to this location when no mirror is found, e.g. MIRRORCACHE_REDIRECT=downloadcontent.opensuse.org</li> <li>MIRRORCACHE_METALINK_PUBLISHER may be set to customize publisher in metalink generation.</li> <li>MIRRORCACHE_METALINK_PUBLISHER_URL may be set to customize url of publisher in metalink generation.</li> <li>MIRRORCACHE_BRANDING loads files from templates/branding. Use the <code>default</code> folder as a base for your own branding and set this environment variable to the name of the newly created folder.</li> <li>MIRRORCACHE_VPN_PREFIX - MirrorCache will use column server.hostname_vpn for redirecting if client IP has prefix as defined by MIRRORCACHE_VPN_PREFIX.</li> </ul> <p>Without any database configuration MirrorCache will attempt to connect to database 'mirrorcache' on default PostgreSQL port 5432. Following variables can be used to configure database access:</p> <ul> <li>MIRRORCACHE_DBUSER (default empty)</li> <li>MIRRORCACHE_DBPASS (default empty)</li> <li>TEST_PG or MIRRORCACHE_DSN , e.g. MIRRORCACHE_DSN='DBI:Pg:dbname=mc_dev;host=/path/to/pg'` If neither TEST_PG nor MIRRORCACHE_DSN is defined, following variables are used:</li> <li>MIRRORCACHE_DB (default 'mirrorcache')</li> <li>MIRRORCACHE_DBHOST (default empty)</li> <li>MIRRORCACHE_DBPORT (default empty)</li> </ul>"},{"location":"setup/#geoip-location","title":"GeoIP location","text":"<ul> <li>If environment variable MIRRORCACHE_CITY_MMDB or MIRRORCACHE_IP2LOCATION is defined, the app will attempt to detect country of the request and find a mirror in the same country, e.g. <code>MIRRORCACHE_CITY_MMDB=/var/lib/GeoIP/GeoLite2-City.mmdb</code> or <code>MIRRORCACHE_IP2LOCATION=/var/lib/GeoIP/IP2LOCATION-LITE-DB5.IPV6.BIN</code>.</li> <li>See Maxmind or IP2Location website to obtain such file.</li> <li>Additional dependencies must be installed as well for GeoIP location to work: perl modules Mojolicious::Plugin::ClientIP and MaxMind::DB::Reader : <pre><code># for Maxmind\nzypper in perl-Mojolicious-Plugin-ClientIP perl-MaxMind-DB-Reader\n\n# for IP2Location\nzypper in perl-Geo-IP2Location\n</code></pre></li> </ul>"},{"location":"setup/#types-of-install","title":"Types of install","text":""},{"location":"setup/#install-package","title":"Install package","text":"<p>An example for openSUSE <pre><code>zypper ar -f obs://openSUSE:infrastructure:MirrorCache MirrorCache\nzypper refresh -s\nzypper install MirrorCache\n\nzypper install postgresql postgresql-server\nsystemctl enable postgresql\n\nsudo -u postgres createuser mirrorcache\nsudo -u postgres createdb mirrorcache\n\n# the services read environment variables from /etc/mirrorcache/conf.env by default\necho \"MIRRORCACHE_ROOT=http://download.opensuse.org\nMIRRORCACHE_TOP_FOLDERS='debug distribution factory history ports repositories source tumbleweed update'\nMOJO_LISTEN=http://*:8000\n\" &gt;&gt; /etc/mirrorcache/conf.env\n\nsystemctl enable mirrorcache\nsystemctl enable mirrorcache-backstage\n</code></pre></p>"},{"location":"setup/#setup-systemd-from-source","title":"Setup systemd from source","text":"<ol> <li>Install prerequisites. The project is based on Perl Mojolicious framework and set of Perl packages. The best way to install them is to reuse zypper and cpanm commands from CI environment:    <code>t/environ/lib/Dockerfile.environ</code></li> </ol> <p>You may skip installing MaxMind::DB::Reader and Mojolicious::Plugin::ClientIP if you don't need Geolocation detection, if you don't need MirrorCache to find a mirror in client's country. From now on it will be referenced as 'Geolocation feature'.</p> <ol> <li> <p>You may need GeoIP database (optional, if 'Geolocation feature' is needed). <code>/var/lib/GeoIP/GeoLite2-City.mmdb</code> or <code>/var/lib/GeoIP/IP2LOCATION-LITE-DB5.IPV6.BIN</code> In such case you will also need following command in next step: <pre><code># for MaxMind database\necho MIRRORCACHE_CITY_MMDB=/var/lib/GeoIP/GeoLite2-City.mmdb &gt;&gt; /etc/mirrorcache/conf.env\n# or for IP2Location database\necho MIRRORCACHE_IP2LOCATION=/var/lib/GeoIP/IP2LOCATION-LITE-DB5.IPV6.BIN &gt;&gt; /usr/share/mirrorcache/conf.env\n</code></pre></p> </li> <li> <p>Setup Use following script as root for inspiration (see also t/systemd/01-smoke.t) <pre><code># assume local PostgreSQL server is up and running with default config\nmake install\nmake setup_production_assets\nmake setup_system_user\nmake setup_system_db\n# the services read environment variables from /etc/mirrorcache/conf.env by default\necho \"MIRRORCACHE_ROOT=http://download.opensuse.org\nMIRRORCACHE_TOP_FOLDERS='debug distribution factory history ports repositories source tumbleweed update'\nMOJO_LISTEN=http://*:8000\n\" &gt;&gt; /etc/mirrorcache/conf.env\n\nsystemctl enable mirrorcache\nsystemctl enable mirrorcache-backstage\n\n# log into UI and provide admin rights to the user:\nsudo -u mirrorcache psql -c \"update acc set is_admin=1 where nickname='myusername'\" mirrorcache\n# add mirrors using UI or sql\nsudo -u mirrorcache psql -c \"insert into server(hostname,urldir,enabled,country,region) select 'mirror.aarnet.edu.au','/pub/opensuse/opensuse','t','au',''\" mirrorcache\n</code></pre></p> </li> </ol>"},{"location":"setup/#development-setup","title":"Development setup","text":"<ol> <li>Install prerequisites. The project is based on Perl Mojolicious framework and set of Perl packages. The best way to install them is to reuse zypper and cpanm commands from CI environment:    <code>t/environ/lib/Dockerfile.environ</code></li> </ol> <p>You may skip installing MaxMind::DB::Reader and Mojolicious::Plugin::ClientIP if you don't need Geolocation detection, if you don't need MirrorCache to find a mirror in client's country. From now on it will be referenced as 'Geolocation feature'.</p> <ol> <li> <p>You may need GeoIP database (optional, if 'Geolocation feature' is needed). <code>/var/lib/GeoIP/GeoLite2-City.mmdb</code> or <code>/var/lib/GeoIP/IP2LOCATION-LITE-DB5.IPV6.BIN</code></p> </li> <li> <p>You will need PostgreSQL server running, create database for mirrorcache and create tables: <pre><code>createdb mc_dev\npsql -f sql/schema.sql mc_dev\n</code></pre> It is possible to run PostgreSQL on dedicated server as well.</p> </li> <li> <p>Example parameters to start WebApp: <pre><code>TEST_PG='DBI:Pg:dbname=mc_dev;host=/path/to/pg' \\\nMIRRORCACHE_ROOT=http://download.opensuse.org \\\nMIRRORCACHE_TOP_FOLDERS='debug distribution factory history ports repositories source tumbleweed update' \\\nMIRRORCACHE_CITY_MMDB=/var/lib/GeoIP/GeoLite2-City.mmdb \\ # MIRRORCACHE_IP2LOCATION=/var/lib/GeoIP/IP2LOCATION-LITE-DB5.IPV6.BIN \\\nMOJO_REVERSE_PROXY=1 \\\nMOJO_LISTEN=http://*:8000 \\\nscript/mirrorcache daemon\n</code></pre></p> </li> <li> <p>To start background jobs: <pre><code>TEST_PG='DBI:Pg:dbname=mc_dev;host=/path/to/pg' \\\nMIRRORCACHE_ROOT=http://download.opensuse.org \\\nscript/mirrorcache backstage run -j 16\n</code></pre></p> </li> <li> <p>Add mirrors using UI or sql, e.g.: <pre><code>insert into server(hostname,urldir,enabled,country,region) select 'mirror.aarnet.edu.au','/pub/opensuse/opensuse','t','au','';\ninsert into server(hostname,urldir,enabled,country,region) select 'ftp.iinet.net.au','/pub/opensuse','t','au','';\ninsert into server(hostname,urldir,enabled,country,region) select 'mirror.intergrid.com.au','/opensuse','t','au','';\ninsert into server(hostname,urldir,enabled,country,region) select 'mirror.internode.on.net','/pub/opensuse','t','au','';\ninsert into server(hostname,urldir,enabled,country,region) select 'ftp.netspace.net.au','/pub/opensuse','t','au','';\n</code></pre></p> </li> <li> <p>Log in using UI and add admin privilege to the user: <pre><code>update acc set is_admin=1 where nickname='myusername';\n</code></pre></p> </li> </ol>"},{"location":"setup/#development-setup-using-environ-framework","title":"Development setup using environ framework","text":"<p>environ framework provides a way to manage development setup of various products without root permissions. Such approach is useful in manual and integration testing, especially when various topologies are required. MirrorCache project uses environ framework in CI, e.g. to start several Apache instances, configure them as mirrors, try different scenarios: http/https redirection, one of mirrors is down, a file is gone from a mirror, etc.</p> <p>E.g. steps 2 - 7 above using environ framework. <pre><code># Needs environ utility installed, as well templates for Apache, nginx, postgres, rsync\ngit clone https://github.com/andrii-suse/environ\nsudo make -C environ install\n# First choose a slot to use in script, mc0 - mc9 are available, so several instances at the same time\n# here we will use slot 1 =&gt; mc1, first parameter is where MirrorCache sources are located\nmc=$(environ mc ~/github/MirrorCache)\n# pg1-system2 will setup local instance of Postgres server with data directory in pg1-system2/dt/\n$mc/gen_config MIRRORCACHE_ROOT=http://download.opensuse.org \\\n     MIRRORCACHE_TOP_FOLDERS=\"'debug distribution factory history ports repositories source tumbleweed update'\" \\\n    MIRRORCACHE_CITY_MMDB=/var/lib/GeoIP/GeoLite2-City.mmdb \\ # MIRRORCACHE_IP2LOCATION=/var/lib/GeoIP/IP2LOCATION-LITE-DB5.IPV6.BIN \\\n    MOJO_REVERSE_PROXY=1\n\n$mc/start\n\n$mc/backstage/start\n\n$mc/db/sql \"insert into server(hostname,urldir,enabled,country,region) select 'mirror.aarnet.edu.au','/pub/opensuse/opensuse','t','au',''\"\n\n# check status\n$mc/db/status\n$mc/backstage/status\n$mc/status\n</code></pre></p>"},{"location":"setup/#run-tests-from-tenviron-with-docker-manually-for-debugging","title":"Run tests from t/environ with docker, manually for debugging","text":"<p>Note: Requires docker configured for non-root users</p> <p><code>MIRRORCACHE_CITY_MMDB</code> adds this environment variable inside the container and mounts it as a volume if the file exists on the host</p> <p><code>EXPOSE_PORT</code> maps whatever port you need from the container to host port 80</p> <pre><code>cd t/environ\n\n# Just run the test:\n./01-smoke.sh\n\n# Run the test with your own MIRRORCACHE_CITY_MMDB\nMIRRORCACHE_CITY_MMDB=/var/lib/GeoIP/GeoLite2-City.mmdb ./01-smoke.sh\n\n# Run the test and keep the container, while mapping port 3110 to host port 80\nEXPOSE_PORT=3110 ./01-smoke.sh\n</code></pre> <p>To log in with a fake test-user, change <code>$mc/start</code> to <code>MIRRORCACHE_TEST_TRUST_AUTH=1 $mc/start</code> in your test</p> <p>Setting <code>MIRRORCACHE_TEST_TRUST_AUTH</code> to any number &gt; 1 will result in <code>current_user</code> being <code>undef</code>, so no fake test-user login. You will only have access to some routes defined in lib/MirrorCache/WebAPI.pm.</p> <p>WARNING - Be careful when working inside container: 1. The source tree is mapped to the host, so any changes of source code inside container will be reflected on host and vice versa. 2. The container is removed automatically on next test start of the same test, so any modifications outside source tree will be lost.</p> <p>Don't forget to clean up the test containers when you're done :)</p>"}]}